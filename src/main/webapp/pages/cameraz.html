<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"> -->
    <title>Robot-l1Console</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            position: fixed;
            width: 100vw;
            display: flex;
            height: 100vh;
            overflow: hidden;
            justify-content: center;
            align-items: center;
            padding: 0.3vh 3vh 0.3vh 5vh;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* 高级深色渐变背景 */
            background:
                radial-gradient(circle at 20% 30%, rgba(65, 20, 120, 0.3) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(0, 100, 200, 0.2) 0%, transparent 40%),
                linear-gradient(135deg, #0a0e17 0%, #13182b 50%, #0d1425 100%);
            z-index: -1;
        }

        .hero {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .content1 {
            /* 高级玻璃态效果 */
            background: linear-gradient(135deg,
                    rgba(25, 30, 50, 0.85) 0%,
                    rgba(15, 20, 40, 0.9) 100%);
            backdrop-filter: blur(15px) saturate(150%);
            -webkit-backdrop-filter: blur(15px) saturate(150%);
            border-radius: 2.5vh;
            padding: 0.5vh 2.5vh;
            box-shadow:
                0 1.5vh 3vh rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            position: relative;
        }

        /* 添加装饰性光效 */
        .content1::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg,
                    transparent 0%,
                    rgba(100, 150, 255, 0.4) 20%,
                    rgba(100, 150, 255, 0.6) 50%,
                    rgba(100, 150, 255, 0.4) 80%,
                    transparent 100%);
            z-index: 1;
        }

        h2 {
            text-align: center;
            font-size: 1rem;

            background: linear-gradient(90deg, #6a8cff, #a66cff, #6a8cff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 2vh rgba(106, 140, 255, 0.5);
            font-weight: 600;
            letter-spacing: 0.5px;
            position: relative;
            padding-bottom: 0.3vh;
        }

        h2::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 25%;
            width: 50%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #6a8cff, transparent);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 2vh;
        }

        .status {
            padding: 0.8vh 2.5vh;
            border-radius: 2vh;
            font-weight: 600;
            background: linear-gradient(135deg, #2ed573, #1db954);
            box-shadow: 0 0 1.5vh rgba(46, 213, 115, 0.4);
            font-size: clamp(0.8rem, 2vw, 0.9rem);
            color: white;
            position: relative;
            overflow: hidden;
        }

        .status::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.4),
                    transparent);
            transition: left 0.5s;
        }

        .status:hover::before {
            left: 100%;
        }

        .control-panel {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 2vh;

            flex: 1;
            overflow: hidden;
        }

        .slider-container {
            width: 10%;
            display: flex;
            flex-direction: column;
            justify-content: end;
            align-items: center;


            height: 95%;
        }

        .slider-label {

            font-weight: 600;
            color: #b8c7ff;
            font-size: clamp(0.8rem, 2vw, 0.9rem);
            text-align: center;
            text-shadow: 0 0 5px rgba(184, 199, 255, 0.3);
        }

        .vertical-slider {

            width: 10%;
            height: 100%;
            background: rgba(10, 15, 30, 0.7);
            border-radius: 1.5vh;
            outline: none;
            border: 1px solid rgba(100, 150, 255, 0.2);
            box-shadow:
                inset 0 2px 4px rgba(0, 0, 0, 0.5),
                0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            transform: scaleX(5);
            writing-mode: vertical-lr;
            direction: rtl;
            -webkit-appearance: slider-vertical;
            appearance: slider-vertical;

        }

        .vertical-slider:hover {
            border-color: rgba(100, 150, 255, 0.4);
            box-shadow:
                inset 0 2px 4px rgba(0, 0, 0, 0.5),
                0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 10px rgba(100, 150, 255, 0.2);
        }



        #straightSlider {
            position: relative;
            background-image: linear-gradient(to right,
                    rgba(255, 255, 255, 0.1) 0.1vh,
                    transparent 0.1vh);
            background-size: 20% 100%;
            background-repeat: no-repeat;
        }

        .video-container {
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(10, 15, 30, 0.6);
            border-radius: 1.5vh;
            padding: 0.5vh 0vh;
            border: 1px solid rgba(100, 150, 255, 0.15);
            box-shadow:
                0 0.5vh 1.5vh rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            width: 50%;
            overflow: hidden;
            position: relative;
        }



        #videoDat {
            width: 100%;
            height: 70%;
            border-radius: 1vh;
            box-shadow: 0 0 2vh rgba(0, 0, 0, 0.5);
            background: #000;
            border: 1px solid rgba(100, 150, 255, 0.2);
            object-fit: contain;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1vh;

            width: 100%;
            height: 10%;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 0.5vh;
        }

        .control-group-title {
            font-size: clamp(0.7rem, 2vw, 0.8rem);
            margin-bottom: 1vh;
            color: #b8c7ff;
            font-weight: 600;
            text-align: center;
            text-shadow: 0 0 5px rgba(184, 199, 255, 0.3);
        }

        button {
            background: linear-gradient(135deg, #3a4a7a, #2a3a6f);
            color: white;
            border: none;
            padding: 0.3vh 0.3vh;
            margin: 0.4vh;
            border-radius: 1vh;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow:
                0 0.4vh 0.8vh rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            width: 20vw;
            height: 100%;
            font-size: clamp(0.7rem, 2vw, 0.85rem);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.2),
                    transparent);
            transition: left 0.5s;
        }

        button:hover {
            transform: translateY(-0.2vh);
            box-shadow:
                0 0.6vh 1.2vh rgba(0, 0, 0, 0.4),
                0 0 15px rgba(106, 140, 255, 0.3);
            background: linear-gradient(135deg, #4a5a8a, #3a4a7f);
        }

        button:hover::before {
            left: 100%;
        }

        button:active {
            transform: translateY(0);
            box-shadow:
                0 0.2vh 0.4vh rgba(0, 0, 0, 0.3),
                inset 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .pwm-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(10, 15, 30, 0.6);
            border-radius: 1.5vh;
            padding: 2vh;
            margin-top: 2vh;
            border: 1px solid rgba(100, 150, 255, 0.15);
            box-shadow:
                0 0.5vh 1vh rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            position: relative;
        }

        .pwm-controls::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 1.5vh;
            padding: 1px;
            background: linear-gradient(135deg,
                    rgba(100, 150, 255, 0.2),
                    rgba(166, 108, 255, 0.1));
            -webkit-mask:
                linear-gradient(#fff 0 0) content-box,
                linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
        }

        .pwm-title {
            font-size: clamp(1rem, 3vw, 1.1rem);
            margin-bottom: 1.5vh;
            color: #b8c7ff;
            text-shadow: 0 0 5px rgba(184, 199, 255, 0.3);
        }

        .pwm-inputs {
            display: flex;
            gap: 2vh;
            margin-bottom: 1.5vh;
            flex-wrap: wrap;
            justify-content: center;
        }

        .pwm-input {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .pwm-input label {
            margin-bottom: 0.8vh;
            font-size: clamp(0.7rem, 2vw, 0.85rem);
            color: #b8c7ff;
        }

        input[type="number"] {
            padding: 1vh;
            border-radius: 0.8vh;
            border: 1px solid rgba(100, 150, 255, 0.3);
            background: rgba(10, 15, 30, 0.7);
            color: white;
            width: clamp(100px, 20vw, 130px);
            text-align: center;
            font-size: clamp(0.8rem, 2vw, 0.9rem);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: rgba(100, 150, 255, 0.6);
            box-shadow:
                inset 0 1px 3px rgba(0, 0, 0, 0.5),
                0 0 8px rgba(100, 150, 255, 0.3);
        }

        .horizontal-slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            margin-top: 0.5vh;
            height: 10%;
            margin-top: auto;
        }

        .horizontal-slider {
            width: 80%;

            margin: 0.2vh 0;
            transform: scaleY(4);

        }

        @media screen and (max-width: 12000px) and (orientation: portrait) {
            body {
                height: 100vw;
                width: 100vh;
                top: 50vh;
                left: 50vw;
                margin-top: -50vw;
                margin-left: -50vh;
                transform: rotate(-90deg);
                transform-origin: center center;
            }
        }

        @media screen and (max-width: 768px) {}
    </style>
</head>

<body>
    <section class="hero">
        <div class="content1">
            <h2>Robot-l1Console</h2>

            <!-- <div class="status-indicator">
                <div id="status" class="status">观察窗</div>
            </div> -->

            <div class="control-panel">
                <div class="slider-container">
                    <div class="slider-label">左控制</div>

                    <input type="range" min="-5" max="5" value="0" class="vertical-slider" id="leftSlider"
                        orient="vertical">

                </div>

                <div class="slider-container">
                    <div class="slider-label">上下调整视角</div>
                    <input type="range" min="5" max="25" value="15" id="upSlider" class="vertical-slider"
                        orient="vertical">
                </div>

                <div class="video-container">
                    <img id="videoDat" src="" alt="等待视频数据">

                    <div class="controls">
                        <div class="control-group">
                            <button id="startvideo" onclick="startvideo()">开始观察</button>

                        </div>

                        <div class="control-group">
                            <button id="stopvideo" onclick="stopvideo()">停止观察</button>

                        </div>

                        <div class="control-group">

                            <button id="rightstopButton" onclick="sendMessageToWebSocket(6)">紧急制动</button>

                        </div>
                    </div>

                    <div class="horizontal-slider-container">
                        <!-- <div class="slider-label">水平调整视角</div> -->
                        <input type="range" min="-25" max="-5" value="-15" id="diSlider" class="horizontal-slider">
                    </div>
                </div>

                <div class="slider-container">
                    <div class="slider-label">右控制</div>
                    <input type="range" min="-5" max="5" value="0" class="vertical-slider" id="rightSlider"
                        orient="vertical">
                </div>

                <div class="slider-container">
                    <div class="slider-label">直线控制</div>
                    <input type="range" min="-5" max="5" value="0" class="vertical-slider" id="straightSlider"
                        orient="vertical">
                </div>
            </div>

            <!-- <div class="pwm-controls">
                <div class="pwm-title">PWM 设置</div>
                <div class="pwm-inputs">
                    <div class="pwm-input">
                        <label for="analogWriteFreq">频率 (Hz)</label>
                        <input type="number" id="analogWriteFreq" name="analogWriteFreq" min="1" max="1000" value="1000">
                    </div>
                    <div class="pwm-input">
                        <label for="analogWriteRange">范围 (1-255)</label>
                        <input type="number" id="analogWriteRange" name="analogWriteRange" min="1" max="255" value="255">
                    </div>
                </div>
                <button id="analogWriteButton">发送 PWM 设置</button>
            </div> -->
        </div>
    </section>
    <script>
        //视频转发控制

        async function startvideo() {
            await fetch('https://linyi.love:25572/videostart',)
        }
        async function stopvideo() {
            await fetch('https://linyi.love:25572/videostop',)
        }

        const wsUrl_control = 'wss://' + 'linyi.love' + ':443/car-user';
        const websocket_ctrl = new WebSocket(wsUrl_control);
        websocket_ctrl.binaryType = 'arraybuffer';
        const zhiling = new Uint8Array(5);
        function sendMessageToWebSocket(message) {
            if (websocket_ctrl.readyState === WebSocket.OPEN) {

                zhiling[0] = 109;
                zhiling[1] = 111;
                zhiling[2] = 118;
                zhiling[3] = 101;
                zhiling[4] = message;
                websocket_ctrl.send(zhiling);
            } else {
                console.error("WebSocket 连接未打开");
            }
        }
        //滑动杆相关
        const leftSlider = document.getElementById("leftSlider");
        const rightSlider = document.getElementById("rightSlider");
        const upSlider = document.getElementById("upSlider");
        const diSlider = document.getElementById("diSlider");
        const straightSlider = document.getElementById("straightSlider");
        leftSlider.addEventListener("input", function () {
            if (leftSlider.value > 0) {
                sendfuzaMessageToWebSocket(9, getspeed(leftSlider.value, "left"));
            } else if (leftSlider.value < 0) {
                sendfuzaMessageToWebSocket(10, getspeed((-leftSlider.value).toString(), "left"));
            } else {
                sendfuzaMessageToWebSocket(10, 0);
            }

        })
        rightSlider.addEventListener("input", function () {
            if (rightSlider.value > 0) {
                sendfuzaMessageToWebSocket(7, getspeed(rightSlider.value, "right"));
            } else if (rightSlider.value < 0) {
                sendfuzaMessageToWebSocket(8, getspeed((-rightSlider.value).toString(), "right"));
            } else {
                sendfuzaMessageToWebSocket(8, 0);
            }
        })
        upSlider.addEventListener("input", function () {
            sendfuzaMessageToWebSocket(14, upSlider.value);

        })
        diSlider.addEventListener("input", function () {
            sendfuzaMessageToWebSocket(15, -diSlider.value);
        })
        straightSlider.addEventListener("input", function () {
            if (straightSlider.value > 0) {
                switch (straightSlider.value) {
                    case '1':

                        sendStraightMessageToWebSocket(11, 20, 15);
                        break;
                    case '2':
                        sendStraightMessageToWebSocket(11, 27, 16);
                        break;
                    case '3':
                        sendStraightMessageToWebSocket(11, 94, 52);
                        break;
                    case '4':
                        sendStraightMessageToWebSocket(11, 180, 100);
                        break;
                    case '5':
                        sendStraightMessageToWebSocket(11, 200, 110);
                        break;
                }

            } else if (straightSlider.value < 0) {
                switch (straightSlider.value) {
                    case '-1':
                        sendStraightMessageToWebSocket(12, 20, 15);
                        break;
                    case '-2':
                        sendStraightMessageToWebSocket(12, 27, 16);
                        break;
                    case '-3':
                        sendStraightMessageToWebSocket(12, 94, 52);
                        break;
                    case '-4':
                        sendStraightMessageToWebSocket(12, 180, 100);
                        break;
                    case '-5':
                        sendStraightMessageToWebSocket(12, 200, 110);
                        break;
                }
            } else {
                sendMessageToWebSocket(6);
            }
        })
        const fuzazhiling = new Uint8Array(7);
        function sendfuzaMessageToWebSocket(message, speed) {
            if (websocket_ctrl.readyState === WebSocket.OPEN) {

                fuzazhiling[0] = 109;
                fuzazhiling[1] = 111;
                fuzazhiling[2] = 118;
                fuzazhiling[3] = 101;
                fuzazhiling[4] = message;
                // fuzazhiling[5] = speed;//右边
                // fuzazhiling[6] = (speed);//左边
                fuzazhiling[5] = speed;//右边
                fuzazhiling[6] = speed;//左边
                websocket_ctrl.send(fuzazhiling);
            } else {
                console.error("WebSocket 连接未打开");
            }
        }
        function sendStraightMessageToWebSocket(message, speedl, speedr) {
            if (websocket_ctrl.readyState === WebSocket.OPEN) {

                fuzazhiling[0] = 109;
                fuzazhiling[1] = 111;
                fuzazhiling[2] = 118;
                fuzazhiling[3] = 101;
                fuzazhiling[4] = message;
                // fuzazhiling[5] = speed;//右边
                // fuzazhiling[6] = (speed);//左边
                fuzazhiling[5] = speedr;//右边
                fuzazhiling[6] = speedl;//左边
                websocket_ctrl.send(fuzazhiling);
            } else {
                console.error("WebSocket 连接未打开");
            }
        }
        function getspeed(nunber, direction) {
            let speed;

            if (direction == "right") {
                switch (nunber) {
                    case '1':
                        speed = 15;
                        break;
                    case '2':
                        speed = 16;
                        break;
                    case '3':
                        speed = 52;
                        break;
                    case '4':
                        speed = 100;
                        break;
                    case '5':
                        speed = 110;
                        break;
                }
            } else {
                switch (nunber) {
                    case '1':
                        speed = 20;
                        break;
                    case '2':
                        speed = 27;
                        break;
                    case '3':
                        speed = 94;
                        break;
                    case '4':
                        speed = 180;
                        break;
                    case '5':
                        speed = 200;
                        break;
                }
            }
            return speed;
        }
        //pwm相关
        const analogWriteFreq = document.getElementById("analogWriteFreq");
        const analogWriteRange = document.getElementById("analogWriteRange");
        const pwmzhiling = new Uint8Array(8);
        function sendAnalogWrite() {
            if (websocket_ctrl.readyState === WebSocket.OPEN) {
                pwmzhiling[0] = 109;
                pwmzhiling[1] = 111;
                pwmzhiling[2] = 118;
                pwmzhiling[3] = 101;
                pwmzhiling[4] = 13;
                pwmzhiling[5] = analogWriteFreq.value / 256;
                pwmzhiling[6] = analogWriteFreq.value % 256;
                pwmzhiling[7] = analogWriteRange.value;
                websocket_ctrl.send(pwmzhiling);
            }
        }
        // 在文件顶部添加全局开关
        const LOG_ENABLED = false; // 设为false即可关闭所有日志

        // 替换所有console.log为条件输出
        function log(...args) {
            if (LOG_ENABLED) {
                console.log(...args);
            }
        }
        //2025.11.1
        const workerCode = `
// 视频处理Worker
let lastFrameTime = 0;
const frameInterval = 0;
let frameBuffer = [];
let combined = new Uint8Array(0);
let totalLength = 0;
const MAX_FRAME_SIZE = 20000;
let board = 0;
//MAX_FRAME_SIZE * 2;
const LOG_ENABLED = false; // 设为false即可关闭所有日志

    // 替换所有console.log为条件输出
    function log(...args) {
        if (LOG_ENABLED) {
            console.log(...args);
        }
    }  


    self.onmessage = function(e) {
        //console.error("线程2接到数据:"+Date.now()); 
        combined = e.data;  
        // 输出：1725524400000（示例值）
        // frameBuffer.push(combined);
        // frameBuffer.push(new Uint8Array(data));
        // let offset = 0;
        // 1. 将新接收的数据添加到缓冲区
        //totalLength = frameBuffer.reduce((sum, arr) => sum + arr.length, 0);
        //combined=new Uint8Array(totalLength);
        // for (const arr of frameBuffer) {
        //     combined.set(arr, offset);
        //     offset += arr.length;
        // }
        //frameBuffer = [];
        let booleanMain=true;//用于判断是否要退出while循环
        while(true){
            if (isFrameComplete()) {
                // 处理完整帧数据
                booleanMain=processFrame();
                if(!booleanMain){
                    booleanMain=!booleanMain;
                    break;
                }
            }else{                      
                log("且是combined.length:"+combined.length);
                break;
            }
        }
        //console.log("线程2结束:"+Date.now()); // 输出：1725524400000（示例值）
        //判断缓冲区是否要处理
        function isFrameComplete(){
            if(combined.length < board){
                //console.log("conbined小于一帧:"+combined.length+"board:"+board);
                return false;
            }else if(combined.length > 1024*1024){//conbined太大了，处理不过来的
               // console.log("combined大于20kb:"+combined.length);
                combined=new Uint8Array(0);
                return false;
            }else{
                return true;
            }
        }
        //处理并渲染图像
        function processFrame(){
            const now = Date.now();
            if (now - lastFrameTime < frameInterval) return;
            lastFrameTime = now;
            let startIndex=0;
            let lengthStartBytes=0;
            let imagelength=0;
            let bytes =new Uint8Array(4);
            //找到picStartindex；
            let j=0;
            for(let i=0;i<combined.length;i++){
                j=0;
                while(combined[i+j] == 119+j){
                    j++;
                }
                if(j==8){
                    log("找到图像第一个标志位");
                   // console.log("combined:"+combined.length);
                   // console.log("i:"+i);
                    startIndex=12;
                    lengthStartBytes=8;
                    combined=combined.subarray(i);
                    //log("j:"+j)
                    break;
                }
            }  
            if(j!=8){//表示一轮下来没有找到图像第一个标志位
                console.error("i!=8，一轮下来没有找到图像第一个标志位");
                combined=new Uint8Array(0);//既然这些数据都没有起始位，那就不可能被显示
                return false;
            }
            //获取表示图像长度的四个字节
            for(let i=0;i<4;i++){
                bytes[i]=combined[lengthStartBytes+i];
            }
            imagelength=bytesToUInt32BE(bytes);
            if(imagelength>MAX_FRAME_SIZE||imagelength<0){
                console.error("imagelength解析错误:"+imagelength);
                for(let i=0;i<13;i++){
                    console.log(i+":"+combined[i]);
                }
                return false;
            }
            if(imagelength+12>combined.length){//图像比实际的小300字节，我也放他过去了
                console.error("imagelength:"+imagelength+"conbined长度短于image长度："+combined.length);
                //console.error();
                //console.error("startIndex:"+startIndex);
                //board=imagelength+12;
                return false;
            }
            bytes =new Uint8Array(4);
            log("imagelength:"+imagelength);
            log("startIndex:"+startIndex);
            log("lengthStartBytes:"+lengthStartBytes);
           
            //console.log("combined.length:"+combined.length);
            self.postMessage(combined.subarray(startIndex,startIndex+imagelength));  // 发送 Uint8Array 到主线程
            //console.log("线程2处理好照片交给主线程显示");
            // 6. 移除已处理的帧数据，保留剩余缓冲区内容
            //获取下一帧的长度，开始位置
        }
        function bytesToUInt32BE(bytes) {
        return (bytes[0] << 24) | 
                (bytes[1] << 16) | 
                (bytes[2] << 8) | 
                (bytes[3]) >>> 0;
        }
        
    };
  
`;


        // // 创建Blob URL
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);
        const transportButton = document.getElementById('transportButton');
        document.addEventListener('DOMContentLoaded', function () {
            // let lastFrameTime = 0;
            // const frameInterval = 0; // 第一个包来了之后累积19ms的rawbuffer 


            // 使用内联Worker
            const videoWorker = new Worker(workerUrl);
            //const videoWorker = new Worker('worker.js');
            const imgElement = document.getElementById('videoDat');
            // 接收Worker处理结果
            videoWorker.onmessage = function (e) {
                const imageData = e.data;
                // console.log("最终处理结果："+e.data);            //console.error("2线程处理好照片交给主线程显示："+Date.now());
                displayImage(imageData, 'image/jpeg');
                // console.log("显示完毕："+Date.now());
            };
            // 图像处理函数
            function displayImage(uint8Array, mimeType = 'image/jpeg') {
                const beginTime = Date.now();
                try {
                    if (uint8Array.length == 0) {
                        throw new Error("图像uint8Array.length == 0"); // 触发catch块
                    }
                    ////检查 jpeg图像尾标志位
                    if (uint8Array[uint8Array.length - 2] != 255 || uint8Array[uint8Array.length - 1] != 217) {
                        // return;
                        console.error("图像uint8Array[uint8Array.length-2]!=255||uint8Array[uint8Array.length-1]!=217");
                        return;//下面是向前找图像尾标志位
                        // //     log("imagelength:"+imagelength);
                        // //    log("startIndex:"+startIndex);
                        // //     log("lengthStartBytes:"+lengthStartBytes); 
                        // //     log("uint8Array.length:"+uint8Array.length);
                        // //     log("combined.length:"+combined.length);
                        // let index = uint8Array.length - 1;
                        // //查找jpeg图像尾标志位
                        // while (index > uint8Array.length - 300) {//图像小于长度的一半就不查找了
                        //     if (uint8Array[index - 1] != 255 || uint8Array[index] != 217) {
                        //         index--;
                        //     } else {
                        //         break;
                        //     }
                        // }
                        // if (index == uint8Array.length - 300) {
                        //     //console.log("uint8Array.length:"+uint8Array.length);
                        //     //                           // 调试 将循环日志放入可折叠组
                        //     // console.groupCollapsed(`字节数组 (长度: ${uint8Array.length})`);
                        //     // for(let i=0; i<uint8Array.length; i++){
                        //     //     console.log(`[${i}]: ${uint8Array[i]}`);
                        //     // }
                        //     // console.groupEnd();
                        //     throw new Error("找不到jpeg图像尾标志位"); // 触发catch块
                        // } else {
                        //     log("找到jpeg图像尾标志位index:" + index);
                        // }
                        // // 移除无效数据
                        // uint8Array = uint8Array.subarray(0, index + 1);
                        // //   // 调试 将循环日志放入可折叠组
                        // //     console.groupCollapsed(`字节数组 (长度: ${uint8Array.length})`);
                        // //     for(let i=0; i<uint8Array.length; i++){
                        // //         console.log(`[${i}]: ${uint8Array[i]}`);
                        // //     }
                        // //     console.groupEnd();

                    }
                    ////检查 jpeg图像头标志位
                    if (uint8Array[0] != 255 || uint8Array[1] != 216) {
                        throw new Error("图像uint8Array[0]!=255||uint8Array[1]!=216"); // 触发catch块
                    }

                    // 创建 Blob 对象
                    const blob = new Blob([uint8Array], { type: mimeType });
                    //用blob创建图像
                    // // 使用createImageBitmap提高解码性能
                    // createImageBitmap(blob).then(imageBitmap => {
                    //     const canvas = document.createElement('canvas');
                    //     const ctx = canvas.getContext('2d');

                    //     // 设置旋转后的尺寸
                    //     canvas.width = 320;
                    //     canvas.height = 240;

                    //     // 执行旋转
                    //     ctx.save();
                    //     ctx.translate(canvas.width / 2, canvas.height / 2);
                    //     ctx.rotate(-90 * Math.PI / 180);
                    //     ctx.drawImage(imageBitmap, -imageBitmap.width / 2, -imageBitmap.height / 2);
                    //     ctx.restore();

                    //     // 直接设置src，避免额外URL创建
                    //     imgElement.src = canvas.toDataURL();
                    // })
                    //  生成临时 URL
                    const url = URL.createObjectURL(blob);
                    imgElement.src = url;

                    const haoshi = Date.now() - beginTime;
                    if (haoshi > 2) {
                        console.log("displayimage:" + "耗时:" + haoshi);
                    }

                } catch (error) {
                    console.error("显示图像错误:" + error);
                }
            }

            let rawbuffer = new Uint8Array(0);
            let hashmap = new Map();
            let completePicIndexs = new Map();//记录每帧图片的起始标志在hashmap中位置
            let finalCompletePicIndexs = new Map();//记录每帧图片的起始标志在hashmap中位置
            let finalIndex = 0;//记录hashmap中最后一个包的序号
            let startIndex = 0;//记录哪一个hashmap正在被读到dataFromHashmap里
            let insertHashCount = 0;//记录udp包被插入到hashmap中的次数
            // let onmessageCount1 = 0;//记录onmessage次数
            //let dataFromHashmap = new Uint8Array(0);
            let MissingNumber = 0;

            let CountofMissingtoomuchNumber = 0;

            //用这个结构体来记录完整的图片在哪几个udp包
            class IntPair {
                constructor(int1, int2) {//int1是包图片头的序号，int2是图片包含包的个数
                    this.int1 = int1; // 第一个整数
                    this.int2 = int2; // 第二个整数
                }
            }

            //
            //接收视频数据
            //
            /////////////////////////////////////////////////////////////////////////////////
            // 创建流URL映射对象
            let streamURLs;

            // 动态生成32-100的URL
            streamURLs = `https://linyi.love:4444/webtransport`;

            beforeStartStreaming(streamURLs);
            async function beforeStartStreaming(streamURLs) {



                startStreaming(streamURLs);



            }

            async function startStreaming(url) {
                try {
                    // 使用 AbortController
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 1000 * 600); // 10分钟超时
                    //webtransport
                    const transport = new WebTransport(url);
                    // The connection can be used once ready fulfills
                    await transport.ready;

                    const reader = transport.datagrams.readable.getReader();
                    //const stream = await transport.createBidirectionalStream();
                    // stream.readable is a WebTransportReceiveStream
                    //const readable = stream.readable;
                    // stream.writable is a WebTransportSendStream
                    //const writable = stream.writable;
                    //const reader = readable.getReader();
                    const writer = transport.datagrams.writable.getWriter();
                    // const data1 = new Uint8Array([65, 66, 67]);
                    // const data2 = new Uint8Array([68, 69, 70]);
                    clearTimeout(timeoutId);
                    console.log("开始连接:" + url);
                    //检查响应状态
                    // if (!response.ok) {
                    //     throw new Error(`HTTP错误! 状态码: ${response.status}`);
                    // }

                    // console.log("开始接收视频流");
                    // transportButton.addEventListener('click', function () {
                    //     writer.write(data1);
                    //     writer.write(data2);
                    // })

                    while (true) {
                        try {
                            //console.log("我又来了");
                            const { done, value } = await reader.read();

                            if (done) {
                                console.log("视频流结束");
                                break;
                            }
                            if (value.byteLength == 0) {
                                console.log("value.byteLength==0");
                                continue;
                            }
                            // 处理接收到的视频数据

                            //console.log(`接收到 ${value.byteLength} 字节数据`);
                            addmessage(value);
                        } catch (error) {
                            console.error("读取数据错误:", error);
                            break;
                        }
                    }
                } catch (error) {
                    console.log(`连接错误: ${error.message}`);
                }
            }
            ////////////////////////////////////////////

            function addmessage(message) {
                //onmessageCount1++; //记录onmessage次数
                //console.log("开始给rawbuffer加数据:"+Date.now()); // 输出：1725524400000（示例值）

                //把来的数据加到缓冲里
                const newData = new Uint8Array(message);
                //console.log("newData.length:"+newData.length);

                // console.groupCollapsed(`字节数组 (长度: ${newData.length})`);
                // for(let i=0; i<newData.length; i++){
                //     console.log(`[${i}]: ${newData[i]}`);
                // }
                // console.groupEnd();

                const newBuffer = new Uint8Array(rawbuffer.length + newData.length);

                newBuffer.set(rawbuffer, 0);            // 复制旧数据
                newBuffer.set(newData, rawbuffer.length); // 追加新数据

                rawbuffer = newBuffer;
                log("rawbuffer.length:" + rawbuffer.length);

                // 更新rawbuffer
                // if(rawbuffer.length<1436*2){
                //     log("rawbuffer.length<1436*2，小于两个udp包，就不处理");
                //     return;
                // }
                //console.log("开始给hashmap加数据:"+Date.now()); // 输出：1725524400000（示例值）

                let index = 0;
                //console.log("rawbuffer.length:"+rawbuffer.length);

                //查找rawbuffer中的包，把包加到hashmap里
                while (index < rawbuffer.length) {
                    // console.groupCollapsed(`字节数组 (长度: ${rawbuffer.length})`);
                    // for(let i=0;i<rawbuffer.length;i++){
                    //     console.log("rawbuffer["+i+"]:"+rawbuffer[i+index]);
                    // }
                    // console.groupEnd();
                    //console.log("rawbuffer.length:"+rawbuffer.length);
                    //console.log("index:"+index);
                    if (rawbuffer[index] == 243 && rawbuffer[index + 1] == 126 && rawbuffer[index + 2] == 98 && rawbuffer[index + 3] == 211) {
                        // for(let i=0;i<10;i++){
                        //     console.log("rawbuffer["+i+"]:"+rawbuffer[i+index]);
                        // }
                        log("rawbuffer[index]:" + rawbuffer[index]);

                        //找到了一个包的起始标志
                        rawbuffer = rawbuffer.subarray(index);
                        //key是包的序号
                        let key = rawbuffer[4] * 256 + rawbuffer[5];
                        //length是包的长度

                        let length = rawbuffer[8] * 256 + rawbuffer[9];
                        //剩余数据长度小于包的长度，就不处理，rawbuffer继续累计数据去吧
                        if (length > rawbuffer.length - 10) {
                            console.log("length>rawbuffer.length-10，包长度大于剩余数据长度");

                            break;
                        }
                        //value是包的内容，
                        log("rawbuffer.length:" + rawbuffer.length);
                        log("length:" + length);
                        log("rawbuffer.length:" + rawbuffer.length);
                        //找到picStartindex；
                        let j = 0;
                        for (let i = 10; i < 18; i++) {//从第10个字节开始查找(也就是跳过udp包的起始标志)，查找图像第一个标志位
                            j = 0;
                            while (rawbuffer[i + j] == 119 + j) {
                                j++;
                            }
                            if (j == 8) {
                                //console.log("找到图像第一个标志位");
                                // console.log("combined:"+combined.length);
                                // console.log("i:"+i);
                                //log("j:"+j)
                                const picLength = rawbuffer[20] * 256 + rawbuffer[21];//获取图片长度(单位是字节且是大端序且是uint16_t类型)
                                const picPackageCount = Math.ceil(picLength / 1334);
                                //console.log("push"+key);
                                const picheader = key;

                                const structData = new IntPair(picheader, picPackageCount);
                                completePicIndexs.set(picheader, structData);
                                //console.log("completePicIndexs:"+key);
                                break;
                            }
                        }
                        //completePicIndexs.push(key);
                        // console.log("completePicIndexs:"+key+"时间："+Date.now());
                        insertHashCount++; //记录insertHashCount次数  
                        let value = rawbuffer.subarray(10, 10 + length);
                        log("value.length:" + value.length);
                        hashmap.set(key, value);
                        //console.log("hashmap:" + key);

                        log("value.length:" + value.length);
                        //更新finalIndex
                        if (key > finalIndex) {
                            finalIndex = key;
                        }
                        //删除rawbuffer中已经处理过的部分
                        rawbuffer = rawbuffer.subarray(10 + length);
                        //重置index
                        index = 0;
                        //如果是第一次onmessage，告诉程序从第一次到的包序号开始处理
                        if (insertHashCount == 1) {
                            startIndex = key;
                        }

                    } else {
                        index++;
                    }
                }
                //检查hashmap中是否有缺失的包
                //从startIndex开始检查hashmap中的数据，直到hashmap中没有数据为止
                //把接收到的完整的图片是哪个udp包到哪个udp包标出来
                markCompletedPic(hashmap, completePicIndexs, finalCompletePicIndexs, startIndex, finalIndex);//执行了之后finalCompletePicIndexs
                // 里面就有完整的图片的起始标志和包的个数

                let dataFromHashmap = new Uint8Array(0);
                const lastStartIndex = startIndex;
                for (let i = startIndex; i <= finalIndex; i++) {

                    if (finalCompletePicIndexs.has(i)) {
                        const structData = finalCompletePicIndexs.get(i);
                        const picheader = structData.int1;
                        const picPackageCount = structData.int2;
                        for (let j = 0; j < picPackageCount; j++) {
                            if (!hashmap.has(i + j)) {
                                console.error("finalConletePicIndex有缺失的包");
                                break;
                            }
                            //把hashmap中的数据加到dataFromHashmap中
                            const newDatax = hashmap.get(i + j);
                            log("i:" + i);
                            //log("finalIndex:"+fangrudata);
                            log("newDatax:" + newDatax.length)
                            const newLength = dataFromHashmap.length + newDatax.length;

                            // 创建新数组
                            const newEventData = new Uint8Array(newLength);

                            // 复制旧数据到新数组开头
                            newEventData.set(dataFromHashmap, 0);

                            // 添加新数据到旧数据末尾
                            newEventData.set(newDatax, dataFromHashmap.length);

                            // 更新引用
                            dataFromHashmap = newEventData;
                            //console.log("dataFromHashmap.length:"+dataFromHashmap.length);

                        }
                        startIndex = i + picPackageCount - 1;
                        finalCompletePicIndexs.delete(i);
                    }
                }
                for (let i = lastStartIndex; i < startIndex; i++) {
                    completePicIndexs.delete(i);
                    hashmap.delete(i);
                }

                if (dataFromHashmap.length == 0) {

                    return;
                }
                //console.log("主线程结束:" + dataFromHashmap.length);
                videoWorker.postMessage(dataFromHashmap, [dataFromHashmap.buffer]);

                dataFromHashmap = new Uint8Array(0);

            }

            function markCompletedPic(hashmap, completePicIndexs, finalCompletePicIndexs, startIndex, finalIndex) {
                const INstartIndex = startIndex;
                const INfinalIndex = finalIndex;
                for (let i = startIndex; i <= finalIndex; i++) {
                    if (completePicIndexs.has(i)) {
                        const structData = completePicIndexs.get(i);
                        const picheader = structData.int1;
                        const picPackageCount = structData.int2;
                        //检查hashmap中是否有缺失的包
                        for (let j = 0; j < picPackageCount; j++) {

                            if (!hashmap.has(i + j)) {
                                break
                            }
                            if (j == picPackageCount - 1) {
                                finalCompletePicIndexs.set(picheader, new IntPair(picheader, picPackageCount));
                            }
                        }
                    }
                }
            }
        });
        //completePicIndexs标记了一个个图片在hashmap里面的位置
        //hashmap里面是一个个udp包
        //这个函数负责根据completePicIndexs里面的信息，把hashmap里面完整的图片的udp包找出来
        //条件
        // 确保有至少有两个数，且递增，且从零索引开始，且连续
        //返回-1表示数在整个数组的左边
        //返回-2表示数在整个数组的右边
        //(返回正数表示在这个下标的右边，下一个下边的左边)或者在这个下标
    </script>
</body>

</html>